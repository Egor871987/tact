import fc, { IAsyncPropertyWithHooks } from "fast-check";
import { beginCell, toNano } from "@ton/core";
import type { Address, Cell, Dictionary, DictionaryKeyTypes } from "@ton/core";
import { Blockchain } from "@ton/sandbox";
import type { SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MapTestContract } from "../contracts/output/map-property-based-<__KEY_FILENAME__>-<__VALUE_FILENAME__>_MapTestContract";
import type {
    ClearRequest,
    SetKeyValue,
    DeleteKey,
} from "../contracts/output/map-property-based-<__KEY_FILENAME__>-<__VALUE_FILENAME__>_MapTestContract";

function generateAddress(
    blockchain: Blockchain,
): fc.Arbitrary<Promise<Address>> {
    return fc
        .string()
        .map((str) =>
            blockchain.treasury(str).then((treasury) => treasury.address),
        );
}

function generateCell(): fc.Arbitrary<Cell> {
    return fc.int8Array().map((buf) => {
        return beginCell().storeBuffer(Buffer.from(buf.buffer)).endCell();
    });
}

function generateIntBitLength(bitLength: number, signed: boolean = true) {
    const maxUnsigned = (1n << BigInt(bitLength)) - 1n;

    if (signed) {
        const minSigned = -maxUnsigned / 2n - 1n;
        const maxSigned = maxUnsigned / 2n;
        return fc.bigInt(minSigned, maxSigned);
    } else {
        return fc.bigInt(0n, maxUnsigned);
    }
}

function generateKeyValuePairs<K, V>(
    keyGenerator: () => fc.Arbitrary<K>,
    valueGenerator: () => fc.Arbitrary<V>,
) {
    return fc.array(fc.tuple(keyGenerator(), valueGenerator()));
}

function compareDicts<K extends DictionaryKeyTypes, V>(
    dict1: Dictionary<K, V>,
    dict2: Dictionary<K, V>,
) {
    return (
        dict1.keys().every((key) => dict1.get(key) === dict2.get(key)) &&
        dict2.keys().every((key) => dict2.get(key) === dict1.get(key))
    );
}

type ContractWithContext = {
    blockchain: Blockchain;
    treasury: SandboxContract<TreasuryContract>;
    contract: SandboxContract<MapTestContract>;
};

function sendMessageToContract(
    contract: ContractWithContext,
    message: SetKeyValue | ClearRequest | DeleteKey | null,
) {
    return contract.contract.send(
        contract.treasury.getSender(),
        { value: toNano("1") },
        message,
    );
}

async function initializeContract(
    contract: ContractWithContext,
    keyValuePairs: [
        <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
        <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
    ][],
) {
    for await (const [key, value] of keyValuePairs) {
        await sendMessageToContract(contract, {
            $$type: "SetKeyValue",
            key: await key,
            value: await value,
        });
    }
    return contract;
}

function withClear<Ts>(
    property: IAsyncPropertyWithHooks<Ts>,
    contractWithContext: ContractWithContext,
) {
    return property.afterEach(async () => {
        //Clear map data for next tests
        await sendMessageToContract(contractWithContext, {
            $$type: "ClearRequest",
        });
    });
}

describe("map property based tests, <<__KEY_TS_TYPE__>, <__VALUE_TS_TYPE__>> case", () => {
    let contractWithContext: ContractWithContext;
    const generateAddressLocal = () => generateAddress(contractWithContext.blockchain);

    beforeAll(async () => {
        // Initialize the blockchain and contracts
        const blockchain = await Blockchain.create();

        blockchain.verbosity.print = false;
        contractWithContext = {
            blockchain,
            treasury: await blockchain.treasury("treasury"),
            contract: blockchain.openContract(await MapTestContract.fromInit()),
        };

        // Fund the contract with some TONs
        await sendMessageToContract(contractWithContext, null);
    });

    it("creates empty map", async () => {
        await initializeContract(contractWithContext, []);
        const map = await contractWithContext.contract.getWholeMap();
        expect(map.keys().length).toBe(0);
    });

    it("adds new element in tact's 'map' exactly like in ton's 'Dictionary'", async () => {
        await fc.check(
            withClear(
                fc.asyncProperty(
                    generateKeyValuePairs(
                        <__KEY_GENERATOR__>,
                        <__VALUE_GENERATOR__>,
                    ),
                    <__KEY_GENERATOR__>(),
                    <__VALUE_GENERATOR__>(),
                    async (
                        keyValuePairs: [
                            <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                            <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
                        ][],
                        testKey: <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                        testValue: <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
                    ) => {
                        await initializeContract(
                            contractWithContext,
                            keyValuePairs,
                        );

                        const initialMap: Dictionary<
                            <__KEY_TS_TYPE__>,
                            <__VALUE_TS_TYPE__>
                        > = await contractWithContext.contract.getWholeMap();

                        initialMap.set(await testKey, await testValue);

                        await sendMessageToContract(contractWithContext, {
                            $$type: "SetKeyValue",
                            key: await testKey,
                            value: await testValue,
                        });

                        const finalMap =
                            await contractWithContext.contract.getWholeMap();

                        return compareDicts(initialMap, finalMap);
                    },
                ),
                contractWithContext,
            ),
        );
    });

    it("gets element from tact 'map' exactly like from ton's 'Dictionary'", async () => {
        await fc.check(
            withClear(
                fc.asyncProperty(
                    generateKeyValuePairs(
                        <__KEY_GENERATOR__>,
                        <__VALUE_GENERATOR__>,
                    ),
                    <__KEY_GENERATOR__>(),
                    async (
                        keyValuePairs: [
                            <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                            <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
                        ][],
                        testKey: <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                    ) => {
                        await initializeContract(
                            contractWithContext,
                            keyValuePairs,
                        );
                        const map =
                            await contractWithContext.contract.getWholeMap();

                        expect(
                            await contractWithContext.contract.getGetValue(
                                await testKey,
                            ),
                        ).toBe(map.get(await testKey) ?? null);
                    },
                ),
                contractWithContext,
            ),
        );
    });

    it("deletes key from tact's 'map' exactly like from ton's 'Dictionary'", async () => {
        await fc.check(
            withClear(
                fc.asyncProperty(
                    generateKeyValuePairs(
                        <__KEY_GENERATOR__>,
                        <__VALUE_GENERATOR__>,
                    ),
                    <__KEY_GENERATOR__>(),
                    async (
                        keyValuePairs: [
                            <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                            <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
                        ][],
                        testKey: <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                    ) => {
                        await initializeContract(
                            contractWithContext,
                            keyValuePairs,
                        );

                        const initialMap =
                            await contractWithContext.contract.getWholeMap();
                        initialMap.delete(await testKey);

                        await sendMessageToContract(contractWithContext, {
                            $$type: "DeleteKey",
                            key: await testKey,
                        });

                        const finalMap =
                            await contractWithContext.contract.getWholeMap();

                        return compareDicts(initialMap, finalMap);
                    },
                ),
                contractWithContext,
            ),
        );
    });

    it("check if element exists in tact's 'map' exactly like in ton's 'Dictionary'", async () => {
        await fc.check(
            withClear(
                fc.asyncProperty(
                    generateKeyValuePairs(
                        <__KEY_GENERATOR__>,
                        <__VALUE_GENERATOR__>,
                    ),
                    <__KEY_GENERATOR__>(),
                    async (
                        keyValuePairs: [
                            <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                            <__VALUE_TS_TYPE__> | Promise<<__VALUE_TS_TYPE__>>,
                        ][],
                        testKey: <__KEY_TS_TYPE__> | Promise<<__KEY_TS_TYPE__>>,
                    ) => {
                        await initializeContract(
                            contractWithContext,
                            keyValuePairs,
                        );
                        const map =
                            await contractWithContext.contract.getWholeMap();

                        expect(
                            await contractWithContext.contract.getExists(
                                await testKey,
                            ),
                        ).toBe(map.has(await testKey));
                    },
                ),
                contractWithContext,
            ),
        );
    });
});
