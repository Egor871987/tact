import { Writer } from "@/utils/Writer";
import type { ABIArgument, ContractABI, ABIReceiver } from "@ton/core";
import type { WrappersConstantDescription } from "@/bindings/writeTypescript";
import type { CompilerContext } from "@/context/context";
import type { TypeDescription } from "@/types/types";

function getReceiverFunctionName(receiver: ABIReceiver): string {
    const receiverType = receiver.receiver; // 'internal' or 'external'
    const messageKind = receiver.message.kind; // 'empty', 'typed', 'text', 'any'

    let name = receiverType.charAt(0).toUpperCase() + receiverType.slice(1); // Internal or External

    switch (messageKind) {
        case "empty":
            name += "Empty";
            break;
        case "typed":
            name += "Message";
            name += receiver.message.type ?? "Typed";
            break;
        case "text":
            name += "Text";
            name += receiver.message.text ?? "Empty";
            break;
        case "any":
            name += "Any";
            break;
        default:
            name += "Unknown";
    }

    return name;
}

export function writeTests(
    abi: ContractABI,
    _ctx: CompilerContext,
    _constants: readonly WrappersConstantDescription[],
    _contract: undefined | TypeDescription,
    generatedContractPath: string,
    _init?: {
        code: string;
        system: string | null;
        args: ABIArgument[];
        prefix?:
            | {
                  value: number;
                  bits: number;
              }
            | undefined;
    },
) {
    const w = new Writer();
    const contractName = abi.name ?? "Contract";

    w.write(
        `// !!THIS FILE IS GENERATED BY TACT. THIS FILE IS REGENERATED EVERY TIME, COPY IT TO YOUR PROJECT MANUALLY!!`,
    );
    w.write(`// https://docs.tact-lang.org/book/debug/`);
    w.append();

    w.write(`import { ${contractName} } from './${generatedContractPath}';`);

    w.write(`import { Blockchain, createShardAccount } from "@ton/sandbox";`);
    w.append();

    const FromInit = `FromInit${contractName}`;
    w.write(`export type ${FromInit} = typeof ${contractName}.fromInit;`);
    w.append();
    w.write(`export type TestCase = (fromInit: ${FromInit}) => void;`);
    w.append();

    w.write(`export const test${contractName} = (fromInit: ${FromInit}) => {`);
    w.inIndent(() => {
        w.write(`describe("${contractName} Contract", () => {`);
        w.inIndent(() => {
            w.write("// Test receivers");
            if (abi.receivers && abi.receivers.length > 0) {
                for (const receiver of abi.receivers) {
                    const receiverName = getReceiverFunctionName(receiver);
                    w.write(`test${receiverName}(fromInit);`);
                }
            }
            w.write("// Test getters");
            if (abi.getters && abi.getters.length > 0) {
                for (const getter of abi.getters) {
                    w.write(`getterTest${getter.name}(fromInit);`);
                }
            }
        });
        w.write(`});`);
    });
    w.write(`};`);

    w.append();

    w.write(`const globalSetup = async (fromInit: ${FromInit}) => {`);
    w.inIndent(() => {
        w.append("const blockchain = await Blockchain.create();");
        w.append("// @ts-ignore");
        w.append(`const contract = await blockchain.openContract(await fromInit(
        // TODO: implement default values
    ));
        `);

        w.append(
            "// Universal method for deploy contract without sending message",
        );
        w.append(`await blockchain.setShardAccount(contract.address, createShardAccount({
        address: contract.address,
        code: contract.init!.code,
        data: contract.init!.data,
        balance: 0n,
        workchain: 0
    }));
        `);

        w.append(`const owner = await blockchain.treasury("owner");`);
        w.append(`const notOwner = await blockchain.treasury("notOwner");`);
        w.append();

        w.append(`return { blockchain, contract, owner, notOwner };`);
    });
    w.write("};");
    w.append();

    const generateBody = (functionName: string, name: string) => {
        w.write(`const ${functionName}: TestCase = (fromInit) => {`);
        w.inIndent(() => {
            w.write(`describe("${name}", () => {`);
            w.inIndent(() => {
                w.write(`const setup = async () => {`);
                w.inIndent(() => {
                    w.write(`return await globalSetup(fromInit);`);
                });
                w.write(`};`);
                w.append();
                w.write(
                    `// !!THIS FILE IS GENERATED BY TACT. THIS FILE IS REGENERATED EVERY TIME, COPY IT TO YOUR PROJECT MANUALLY!!`,
                );
                w.write(`// TODO: You can write tests for ${name} here`);
                w.append();
                w.write(`it("should perform correctly", async () => {`);
                w.inIndent(() => {
                    w.write(
                        `const { blockchain, contract, owner, notOwner } = await setup();`,
                    );
                });
                w.write(`});`);
            });
            w.write(`});`);
        });
        w.write(`};`);
        w.append();
    };

    // Generate tests for receivers
    if (abi.receivers && abi.receivers.length > 0) {
        for (const receiver of abi.receivers) {
            const receiverName = getReceiverFunctionName(receiver);
            generateBody("test" + receiverName, receiverName);
        }
    }

    // Generate tests for getters
    if (abi.getters && abi.getters.length > 0) {
        for (const getter of abi.getters) {
            generateBody("getterTest" + getter.name, getter.name);
        }
    }

    w.write("// entry point");
    w.write(
        `test${contractName}(${contractName}.fromInit.bind(${contractName}));`,
    );
    w.append();

    return w.end();
}
